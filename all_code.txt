

// ====== cameracontroller.cpp ====== //

CameraController::CameraController(Scene* scene, QObject* parent)
    : QObject(parent), m_scene(scene)
{
}
void CameraController::mousePressEvent(QMouseEvent* event)
{
    m_lastMousePos = event->pos();
    if (event->button() == Qt::LeftButton) {
        m_isRotating = true;
    } else if (event->button() == Qt::RightButton) {
        m_isPanning = true;
    }
}
void CameraController::mouseMoveEvent(QMouseEvent* event)
{
    QPoint delta = event->pos() - m_lastMousePos;
    m_lastMousePos = event->pos();
    if (m_isRotating) {
        m_rotationAngles.setX(m_rotationAngles.x() + delta.y() * m_rotationSpeed);
        m_rotationAngles.setY(m_rotationAngles.y() - delta.x() * m_rotationSpeed);
        m_rotationAngles.setX(fmod(m_rotationAngles.x(), 360.0f));
        m_rotationAngles.setY(fmod(m_rotationAngles.y(), 360.0f));
        updateCamera();
    }
    else if (m_isPanning) {
        float aspect = float(m_width) / float(m_height);
        float tanFov = tan(qDegreesToRadians(45.0f) / 2.0f);
        QVector3D viewDir = QVector3D(
                                qSin(qDegreesToRadians(m_rotationAngles.y())) * qCos(qDegreesToRadians(m_rotationAngles.x())),
                                qSin(qDegreesToRadians(m_rotationAngles.x())),
                                qCos(qDegreesToRadians(m_rotationAngles.y())) * qCos(qDegreesToRadians(m_rotationAngles.x()))
                                ).normalized();
        QVector3D right = QVector3D::crossProduct(viewDir, QVector3D(0, -1, 0)).normalized();
        QVector3D up = QVector3D::crossProduct(right, viewDir).normalized();
        m_center -= right * (delta.x() * m_panSpeed * m_distance * aspect * tanFov);
        m_center -= up * (delta.y() * m_panSpeed * m_distance * tanFov);
        updateCamera();
    }
}
void CameraController::mouseReleaseEvent(QMouseEvent* event)
{
    if (event->button() == Qt::LeftButton) {
        m_isRotating = false;
    } else if (event->button() == Qt::RightButton) {
        m_isPanning = false;
    }
}
void CameraController::wheelEvent(QWheelEvent* event)
{
    float delta = event->angleDelta().y();
    m_distance *= (1.0f - delta * m_zoomSpeed);
    m_distance = qBound(0.5f, m_distance, 100.0f);
    updateCamera();
}
void CameraController::updateCamera()
{
    float cosX = qCos(qDegreesToRadians(m_rotationAngles.x()));
    float sinX = qSin(qDegreesToRadians(m_rotationAngles.x()));
    float cosY = qCos(qDegreesToRadians(m_rotationAngles.y()));
    float sinY = qSin(qDegreesToRadians(m_rotationAngles.y()));
    QVector3D position(
        m_distance * sinY * cosX,
        m_distance * sinX,
        m_distance * cosY * cosX
        );
    position += m_center;
    QVector3D up = QVector3D(
                       -sinY * sinX,
                       cosX,
                       -cosY * sinX
                       ).normalized();
    m_scene->setCameraPosition(position);
    m_scene->setCameraFront((m_center - position).normalized());
    m_scene->setCameraUp(up);
    emit cameraUpdated();
}
void CameraController::resize(int width, int height)
{
    m_width = width;
    m_height = height;
}


// ====== cameracontroller.h ====== //

class Scene;
class CameraController : public QObject
{
    Q_OBJECT
public:
    explicit CameraController(Scene* scene, QObject* parent = nullptr);
    void setDistance(float distance) { m_distance = distance; updateCamera(); }
    float distance() const { return m_distance; }
    void setRotationSpeed(float speed) { m_rotationSpeed = speed; }
    float rotationSpeed() const { return m_rotationSpeed; }
    void setPanSpeed(float speed) { m_panSpeed = speed; }
    float panSpeed() const { return m_panSpeed; }
    void setZoomSpeed(float speed) { m_zoomSpeed = speed; }
    float zoomSpeed() const { return m_zoomSpeed; }
    void mousePressEvent(QMouseEvent* event);
    void mouseMoveEvent(QMouseEvent* event);
    void mouseReleaseEvent(QMouseEvent* event);
    void wheelEvent(QWheelEvent* event);
    void updateCamera();
    void resize(int width, int height);
signals:
    void cameraUpdated();
private:
    Scene* m_scene;
    float m_distance = 5.0f;
    QVector2D m_rotationAngles = QVector2D(30.0f, 0.0f);
    QVector3D m_center = QVector3D(0, 0, 0);
    float m_rotationSpeed = 0.5f;
    float m_panSpeed = 0.005f;
    float m_zoomSpeed = 0.001f;
    QPoint m_lastMousePos;
    bool m_isRotating = false;
    bool m_isPanning = false;
    int m_width = 1;
    int m_height = 1;
};


// ====== fpscounter.cpp ====== //

FPSCounter::FPSCounter(QWidget *parentWidget) :
    QObject(parentWidget),
    frameCount(0),
    lastTime(0)
{
    fpsLabel = new QLabel(parentWidget);
    fpsLabel->setGeometry(10, 10, 100, 20);
    fpsLabel->setStyleSheet(
        "QLabel {"
        "   color: white;"
        "   font-weight: bold;"
        "   background-color: rgba(0, 0, 0, 150);"
        "   padding: 2px;"
        "   border-radius: 3px;"
        "}"
        );
    fpsLabel->raise();
    fpsLabel->show();
    fpsTimer = new QTimer(this);
    connect(fpsTimer, &QTimer::timeout, this, &FPSCounter::updateFPS);
    fpsTimer->start(100);
}
FPSCounter::~FPSCounter()
{
    delete fpsLabel;
}
void FPSCounter::setVisible(bool visible)
{
    fpsLabel->setVisible(visible);
}
void FPSCounter::setUpdateInterval(int ms)
{
    fpsTimer->setInterval(ms);
}
void FPSCounter::setStyleSheet(const QString &styleSheet)
{
    fpsLabel->setStyleSheet(styleSheet);
}
void FPSCounter::toggleVisibility()
{
    fpsLabel->setVisible(!fpsLabel->isVisible());
}
void FPSCounter::frameRendered()
{
    frameCount++;
}
void FPSCounter::updateFPS()
{
    qint64 currentTime = QDateTime::currentMSecsSinceEpoch();
    if (lastTime == 0) {
        lastTime = currentTime;
        return;
    }
    int fps = frameCount * 1000 / (currentTime - lastTime);
    frameCount = 0;
    lastTime = currentTime;
    fpsLabel->setText(QString("FPS: %1").arg(fps));
    emit fpsUpdated(fps);
}


// ====== fpscounter.h ====== //

class FPSCounter : public QObject
{
    Q_OBJECT
public:
    explicit FPSCounter(QWidget *parentWidget = nullptr);
    ~FPSCounter();
    void setVisible(bool visible);
    void setUpdateInterval(int ms);
    void setStyleSheet(const QString &styleSheet);
    void toggleVisibility();
public slots:
    void frameRendered();
signals:
    void fpsUpdated(int fps);
private:
    void updateFPS();
    QLabel *fpsLabel;
    QTimer *fpsTimer;
    int frameCount;
    qint64 lastTime;
};


// ====== fshader.fsh ====== //

in vec2 TexCoord;
in vec3 Normal;
in vec3 FragPos;
out vec4 FragColor;
uniform sampler2D ourTexture;
uniform vec3 lightPos;
uniform vec3 viewPos;
uniform vec3 lightColor;
uniform vec3 objectColor;
uniform float ambientStrength;
uniform float specularStrength;
uniform int shininess;
void main()
{
    vec3 ambient = ambientStrength * lightColor;
    vec3 norm = normalize(Normal);
    vec3 lightDir = normalize(lightPos - FragPos);
    float diff = max(dot(norm, lightDir), 0.0);
    vec3 diffuse = diff * lightColor;
    vec3 viewDir = normalize(viewPos - FragPos);
    vec3 reflectDir = reflect(-lightDir, norm);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), shininess);
    vec3 specular = specularStrength * spec * lightColor;
    vec3 result = (ambient + diffuse + specular) * objectColor;
    FragColor = texture(ourTexture, TexCoord) * vec4(result, 1.0);
}


// ====== fskybox.fsh ====== //

uniform sampler2D skyTexture;
in vec2 TexCoord;
out vec4 FragColor;
void main()
{
    FragColor = texture(skyTexture, TexCoord);
}


// ====== light.cpp ====== //

Light::Light(QObject* parent)
    : QObject(parent),
    m_position(1.0f, 1.0f, 1.0f),
    m_color(1.0f, 1.0f, 1.0f),
    m_ambientStrength(0.1f),
    m_specularStrength(0.5f),
    m_shininess(32)
{
}
void Light::setPosition(const QVector3D& position)
{
    if (m_position != position) {
        m_position = position;
        emit lightChanged();
    }
}
void Light::setColor(const QVector3D& color)
{
    if (m_color != color) {
        m_color = color;
        emit lightChanged();
    }
}
void Light::setAmbientStrength(float strength)
{
    if (m_ambientStrength != strength) {
        m_ambientStrength = strength;
        emit lightChanged();
    }
}
void Light::setSpecularStrength(float strength)
{
    if (m_specularStrength != strength) {
        m_specularStrength = strength;
        emit lightChanged();
    }
}
void Light::setShininess(int shininess)
{
    if (m_shininess != shininess) {
        m_shininess = shininess;
        emit lightChanged();
    }
}


// ====== light.h ====== //

class Light : public QObject
{
    Q_OBJECT
public:
    explicit Light(QObject* parent = nullptr);
    QVector3D position() const { return m_position; }
    QVector3D color() const { return m_color; }
    float ambientStrength() const { return m_ambientStrength; }
    float specularStrength() const { return m_specularStrength; }
    int shininess() const { return m_shininess; }
    void setPosition(const QVector3D& position);
    void setColor(const QVector3D& color);
    void setAmbientStrength(float strength);
    void setSpecularStrength(float strength);
    void setShininess(int shininess);
signals:
    void lightChanged();
private:
    QVector3D m_position;
    QVector3D m_color;
    float m_ambientStrength;
    float m_specularStrength;
    int m_shininess;
};


// ====== main.cpp ====== //

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    MainWindow w;
    w.show();
    return a.exec();
}


// ====== mainwindow.cpp ====== //

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
    , glWidget(nullptr)
{
    ui->setupUi(this);
    setWindowTitle("3D engine");
    glWidget = new OpenGLWidget(ui->tab);
    QVBoxLayout *tabLayout = new QVBoxLayout(ui->tab);
    tabLayout->addWidget(glWidget);
    ui->tab->setLayout(tabLayout);
    ui->tabWidget->setTabText(0, "Сцена");
    ui->tabWidget->setTabText(1, "Пост-обработка");
    connect(ui->vignetteCheckBox, &QCheckBox::toggled, this, &MainWindow::onVignetteToggled);
    connect(ui->filmGrainCheckBox, &QCheckBox::toggled, this, &MainWindow::onFilmGrainToggled);
    connect(ui->negativeCheckBox, &QCheckBox::toggled, this, &MainWindow::onNegativeToggled);
    connect(ui->sepiaCheckBox, &QCheckBox::toggled, this, &MainWindow::onSepiaToggled);
    connect(ui->fisheyeCheckBox, &QCheckBox::toggled, this, &MainWindow::onFisheyeToggled);
    connect(ui->colorFilterCheckBox, &QCheckBox::toggled, this, &MainWindow::onColorFilterToggled);
    connect(ui->grayscaleCheckBox, &QCheckBox::toggled, this, &MainWindow::onGrayscaleToggled);
    connect(ui->vignetteIntensitySlider, &QSlider::valueChanged, this, &MainWindow::onVignetteIntensityChanged);
    connect(ui->filmGrainIntensitySlider, &QSlider::valueChanged, this, &MainWindow::onFilmGrainIntensityChanged);
    connect(ui->fisheyeStrengthSlider, &QSlider::valueChanged, this, &MainWindow::onFisheyeStrengthChanged);
    connect(ui->colorFilterRedSlider, &QSlider::valueChanged, this, &MainWindow::onColorFilterRedChanged);
    connect(ui->colorFilterGreenSlider, &QSlider::valueChanged, this, &MainWindow::onColorFilterGreenChanged);
    connect(ui->colorFilterBlueSlider, &QSlider::valueChanged, this, &MainWindow::onColorFilterBlueChanged);
}
MainWindow::~MainWindow()
{
    delete ui;
}
void MainWindow::onVignetteToggled(bool checked) {
    glWidget->getPostProcessor()->setVignetteEnabled(checked);
    glWidget->update();
}
void MainWindow::onFilmGrainToggled(bool checked) {
    glWidget->getPostProcessor()->setFilmGrainEnabled(checked);
    glWidget->update();
}
void MainWindow::onNegativeToggled(bool checked) {
    glWidget->getPostProcessor()->setNegativeEnabled(checked);
    glWidget->update();
}
void MainWindow::onSepiaToggled(bool checked) {
    glWidget->getPostProcessor()->setSepiaEnabled(checked);
    glWidget->update();
}
void MainWindow::onFisheyeToggled(bool checked) {
    glWidget->getPostProcessor()->setFisheyeEnabled(checked);
    glWidget->update();
}
void MainWindow::onColorFilterToggled(bool checked) {
    glWidget->getPostProcessor()->setColorFilterEnabled(checked);
    glWidget->update();
}
void MainWindow::onGrayscaleToggled(bool checked) {
    glWidget->getPostProcessor()->setGrayscaleEnabled(checked);
    glWidget->update();
}
void MainWindow::onVignetteIntensityChanged(int value) {
    float intensity = static_cast<float>(value) / 100.0f;
    glWidget->getPostProcessor()->setVignetteIntensity(intensity);
    glWidget->update();
}
void MainWindow::onFilmGrainIntensityChanged(int value) {
    float intensity = static_cast<float>(value) / 100.0f;
    glWidget->getPostProcessor()->setFilmGrainIntensity(intensity);
    glWidget->update();
}
void MainWindow::onFisheyeStrengthChanged(int value) {
    float strength = static_cast<float>(value) / 100.0f;
    glWidget->getPostProcessor()->setFisheyeStrength(strength);
    glWidget->update();
}
void MainWindow::onColorFilterRedChanged(int value) {
    QVector3D color = glWidget->getPostProcessor()->getColorFilterColor();
    color.setX(static_cast<float>(value) / 100.0f);
    glWidget->getPostProcessor()->setColorFilterColor(color);
    glWidget->update();
}
void MainWindow::onColorFilterGreenChanged(int value) {
    QVector3D color = glWidget->getPostProcessor()->getColorFilterColor();
    color.setY(static_cast<float>(value) / 100.0f);
    glWidget->getPostProcessor()->setColorFilterColor(color);
    glWidget->update();
}
void MainWindow::onColorFilterBlueChanged(int value) {
    QVector3D color = glWidget->getPostProcessor()->getColorFilterColor();
    color.setZ(static_cast<float>(value) / 100.0f);
    glWidget->getPostProcessor()->setColorFilterColor(color);
    glWidget->update();
}


// ====== mainwindow.h ====== //

QT_BEGIN_NAMESPACE
namespace Ui {
class MainWindow;
}
QT_END_NAMESPACE
class OpenGLWidget;
class MainWindow : public QMainWindow
{
    Q_OBJECT
public:
    MainWindow(QWidget *parent = nullptr);
    ~MainWindow();
private slots:
    void onVignetteToggled(bool checked);
    void onFilmGrainToggled(bool checked);
    void onNegativeToggled(bool checked);
    void onSepiaToggled(bool checked);
    void onFisheyeToggled(bool checked);
    void onColorFilterToggled(bool checked);
    void onGrayscaleToggled(bool checked);
    void onVignetteIntensityChanged(int value);
    void onFilmGrainIntensityChanged(int value);
    void onFisheyeStrengthChanged(int value);
    void onColorFilterRedChanged(int value);
    void onColorFilterGreenChanged(int value);
    void onColorFilterBlueChanged(int value);
private:
    Ui::MainWindow *ui;
    OpenGLWidget *glWidget;
};


// ====== openglwidget.cpp ====== //

OpenGLWidget::OpenGLWidget(QWidget* parent)
    : QOpenGLWidget(parent)
{
    setFocusPolicy(Qt::StrongFocus);
    cameraController = new CameraController(&scene, this);
    fpsCounter = new FPSCounter(this);
    connect(this, &OpenGLWidget::frameRendered, fpsCounter, &FPSCounter::frameRendered);
    connect(fpsCounter, &FPSCounter::fpsUpdated, this, &OpenGLWidget::fpsUpdated);
    connect(cameraController, &CameraController::cameraUpdated, this, QOverload<>::of(&OpenGLWidget::update));
    QTimer::singleShot(0, this, QOverload<>::of(&OpenGLWidget::update));
}
OpenGLWidget::~OpenGLWidget()
{
    makeCurrent();
    TextureManager::instance().clear();
    doneCurrent();
}
void OpenGLWidget::initializeGL()
{
    light = new Light(this);
    connect(light, &Light::lightChanged, this, QOverload<>::of(&OpenGLWidget::update));
    light->setColor(QVector3D(0.78f, 0.65f, 0.53f));
    light->setAmbientStrength(0.5);
    light->setPosition(QVector3D(-100.0f, 350.0f, 450.0f));
    initializeOpenGLFunctions();
    glClearColor(0.3f, 0.2f, 0.3f, 1.0f);
    glEnable(GL_DEPTH_TEST);
    if (!ShaderManager::instance().loadShaderProgram("default",
                                                     ":/shaders/vshader.vsh",
                                                     ":/shaders/fshader.fsh")) {
        qCritical() << "Failed to load default shaders!";
        return;
    }
    if (!ShaderManager::instance().loadShaderProgram("skybox",
                                                     ":/shaders/vskybox.vsh",
                                                     ":/shaders/fskybox.fsh")) {
        qCritical() << "Failed to load skybox shaders!";
        return;
    }
    program = ShaderManager::instance().getShaderProgram("default");
    skyBoxProgram = ShaderManager::instance().getShaderProgram("skybox");
    postProcessor = new PostProcessor();
    postProcessor->initialize(width(), height());
    if (!ShaderManager::instance().loadShaderProgram("postprocessing",
                                                     ":/shaders/postprocessing.vsh",
                                                     ":/shaders/postprocessing.fsh")) {
        qCritical() << "Failed to load postprocessing shaders!";
    }
    postProcessingProgram = ShaderManager::instance().getShaderProgram("postprocessing");
    TextureManager::instance().loadTexture(":/textures/magma.png", "magma");
    TextureManager::instance().loadTexture(":/textures/wood.png", "wood");
    TextureManager::instance().loadTexture(":/textures/cubes_gray.png", "cubes");
    TextureManager::instance().loadTexture(":/textures/water.png", "water");
    Skybox *skybox = new Skybox();
    skybox->initialize();
    skybox->setScale(QVector3D(500, 500, 500));
    skybox->setRotation(180, QVector3D(0, 1, 0));
    scene.setSkybox(skybox);
    Cube *cube = new Cube("magma");
    cube->initialize();
    cube->setScale(QVector3D(1.5f, 1.5f, 1.5f));
    scene.addShape(cube);
    Pyramid *pyramid = new Pyramid("wood");
    pyramid->initialize();
    pyramid->setPosition(QVector3D(0.0f, 1.35f, 0.0f));
    pyramid->setScale(QVector3D(1.5f, 1.2f, 1.5f));
    scene.addShape(pyramid);
    Sphere *sphere = new Sphere("cubes", 0.5f);
    sphere->initialize();
    sphere->setRotation(90, QVector3D(0, 1, 0));
    scene.addShape(sphere);
    Cylinder *cylinder = new Cylinder("water", 0.45f, 1.0f);
    cylinder->initialize();
    cylinder->setPosition(QVector3D(1.5f, 0.0f, 0.0f));
    cylinder->setRotation(90, QVector3D(0, 1, 0));
    scene.addShape(cylinder);
    cameraController->updateCamera();
}
void OpenGLWidget::initShaders() {
}
void OpenGLWidget::resizeGL(int w, int h)
{
    glViewport(0, 0, w, h);
    scene.resize(w, h);
}
void OpenGLWidget::paintGL()
{
    emit frameRendered();
    postProcessor->beginRender();
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    animCounter += 0.01f;
    scene.getShapes()[2]->setPosition(QVector3D(sin(animCounter) * 3, cos(animCounter) * 3, 0));
    scene.getShapes()[2]->setRotation(1, QVector3D(1, 0, 1));
    scene.getShapes()[3]->setPosition(QVector3D(sin(animCounter) * 1.9, 0, cos(animCounter) * 2));
    scene.getShapes()[3]->setRotation(-1, QVector3D(0, 1, 0));
    deltaTime = frameTimer.restart() / 1000.0f;
    glDepthFunc(GL_LEQUAL);
    if (skyBoxProgram) {
        skyBoxProgram->bind();
        scene.renderSkybox(*skyBoxProgram);
        skyBoxProgram->release();
    }
    glDepthFunc(GL_LESS);
    if (program) {
        program->bind();
        program->setUniformValue("lightPos", light->position());
        program->setUniformValue("viewPos", scene.getCameraPosition());
        program->setUniformValue("lightColor", light->color());
        program->setUniformValue("ambientStrength", light->ambientStrength());
        program->setUniformValue("specularStrength", light->specularStrength());
        program->setUniformValue("shininess", light->shininess());
        program->setUniformValue("objectColor", QVector3D(1.0f, 1.0f, 1.0f));
        scene.renderAll(*program);
        program->release();
    }
    postProcessor->endRender();
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    if (postProcessingProgram) {
        postProcessingProgram->bind();
        postProcessor->applyEffects(*postProcessingProgram);
        postProcessingProgram->release();
    }
    QTimer::singleShot(0, this, QOverload<>::of(&OpenGLWidget::update));
}
void OpenGLWidget::mousePressEvent(QMouseEvent* event)
{
    cameraController->mousePressEvent(event);
    event->accept();
}
void OpenGLWidget::mouseMoveEvent(QMouseEvent* event)
{
    cameraController->mouseMoveEvent(event);
    event->accept();
}
void OpenGLWidget::mouseReleaseEvent(QMouseEvent* event)
{
    cameraController->mouseReleaseEvent(event);
    event->accept();
}
void OpenGLWidget::wheelEvent(QWheelEvent* event)
{
    cameraController->wheelEvent(event);
    event->accept();
}
void OpenGLWidget::keyPressEvent(QKeyEvent *event)
{
    if (event->key() == Qt::Key_F3) {
        fpsCounter->toggleVisibility();
    }
    else if (event->key() == Qt::Key_F2) {
        bool enabled = !postProcessor->areEffectsEnabled();
        postProcessor->toggleEffects(enabled);
        update();
    }
    QOpenGLWidget::keyPressEvent(event);
}


// ====== openglwidget.h ====== //

class OpenGLWidget : public QOpenGLWidget, protected QOpenGLFunctions
{
    Q_OBJECT
public:
    explicit OpenGLWidget(QWidget* parent = nullptr);
    ~OpenGLWidget();
    PostProcessor* getPostProcessor() const { return postProcessor; }
protected:
    void initializeGL() override;
    void initShaders();
    void resizeGL(int w, int h) override;
    void paintGL() override;
    void mousePressEvent(QMouseEvent* event) override;
    void mouseMoveEvent(QMouseEvent* event) override;
    void mouseReleaseEvent(QMouseEvent* event) override;
    void wheelEvent(QWheelEvent* event) override;
    void keyPressEvent(QKeyEvent *event) override;
private:
    QOpenGLShaderProgram *program;
    QOpenGLShaderProgram *skyBoxProgram;
    Scene scene;
    CameraController* cameraController;
    float animCounter;
    QElapsedTimer frameTimer;
    float deltaTime = 0.0f;
    Light* light;
    FPSCounter* fpsCounter;
    PostProcessor* postProcessor;
    QOpenGLShaderProgram* postProcessingProgram;
signals:
    void frameRendered();
    void fpsUpdated(int fps);
};


// ====== postprocessing.fsh ====== //

out vec4 FragColor;
in vec2 TexCoords;
uniform sampler2D screenTexture;
uniform bool useVignette;
uniform bool useFilmGrain;
uniform bool useNegative;
uniform bool useSepia;
uniform bool useFisheye;
uniform bool useColorFilter;
uniform bool useGrayscale;
uniform float vignetteIntensity;
uniform float filmGrainIntensity;
uniform float fisheyeStrength;
uniform vec3 colorFilterColor;
float vignette(vec2 uv, float intensity) {
    vec2 dist = uv - vec2(0.5, 0.5);
    return 1.0 - dot(dist, dist) * intensity;
}
float random(vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453);
}
vec3 applySepia(vec3 color) {
    float r = color.r;
    float g = color.g;
    float b = color.b;
    color.r = min(1.0, (r * 0.393) + (g * 0.769) + (b * 0.189));
    color.g = min(1.0, (r * 0.349) + (g * 0.686) + (b * 0.168));
    color.b = min(1.0, (r * 0.272) + (g * 0.534) + (b * 0.131));
    return color;
}
vec2 fisheye(vec2 uv, float strength) {
    vec2 centered = uv - vec2(0.5, 0.5);
    float dist = length(centered);
    float distortion = 1.0 - strength * dist * dist;
    vec2 distorted = centered * distortion;
    return distorted + vec2(0.5, 0.5);
}
vec3 applyGrayscale(vec3 color) {
    float gray = dot(color, vec3(0.299, 0.587, 0.114));
    return vec3(gray);
}
void main()
{
    vec2 uv = TexCoords;
    if (useFisheye) {
        uv = fisheye(TexCoords, fisheyeStrength);
    }
    uv = clamp(uv, vec2(0.0, 0.0), vec2(1.0, 1.0));
    vec3 color = texture(screenTexture, uv).rgb;
    if (useVignette) {
        color *= vignette(uv, vignetteIntensity);
    }
    if (useFilmGrain) {
        float noise = random(uv * 100.0) * filmGrainIntensity;
        color += vec3(noise) * 0.1;
    }
    if (useNegative) {
        color = vec3(1.0) - color;
    }
    if (useSepia) {
        color = applySepia(color);
    }
    if (useColorFilter) {
        color *= colorFilterColor;
    }
    if (useGrayscale) {
        color = applyGrayscale(color);
    }
    FragColor = vec4(color, 1.0);
}


// ====== postprocessing.vsh ====== //

layout (location = 0) in vec2 aPos;
layout (location = 1) in vec2 aTexCoords;
out vec2 TexCoords;
void main()
{
    TexCoords = aTexCoords;
    gl_Position = vec4(aPos.x, aPos.y, 0.0, 1.0);
}


// ====== postprocessor.cpp ====== //

PostProcessor::PostProcessor()
    : fbo(nullptr), screenWidth(0), screenHeight(0)
{
    initializeOpenGLFunctions();
    quadVBO.create();
}
PostProcessor::~PostProcessor()
{
    delete fbo;
    quadVBO.destroy();
}
void PostProcessor::initialize(int width, int height) {
    screenWidth = width;
    screenHeight = height;
    QOpenGLFramebufferObjectFormat format;
    format.setAttachment(QOpenGLFramebufferObject::CombinedDepthStencil);
    format.setSamples(0); // Попробуйте без мультисэмплинга сначала
    fbo = new QOpenGLFramebufferObject(width, height, format);
    if (!fbo->isValid()) {
        qWarning() << "FBO is not valid!";
    }
    setupScreenQuad();
}
void PostProcessor::resize(int width, int height)
{
    screenWidth = width;
    screenHeight = height;
    delete fbo;
    QOpenGLFramebufferObjectFormat format;
    format.setAttachment(QOpenGLFramebufferObject::CombinedDepthStencil);
    format.setSamples(4);
    fbo = new QOpenGLFramebufferObject(width, height, format);
}
void PostProcessor::beginRender()
{
    if (fbo) {
        fbo->bind();
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    }
}
void PostProcessor::endRender()
{
    if (fbo) {
        fbo->release();
    }
}
void PostProcessor::setupScreenQuad()
{
    float quadVertices[] = {
        -1.0f,  1.0f,  0.0f, 1.0f,
        -1.0f, -1.0f,  0.0f, 0.0f,
        1.0f, -1.0f,  1.0f, 0.0f,
        -1.0f,  1.0f,  0.0f, 1.0f,
        1.0f, -1.0f,  1.0f, 0.0f,
        1.0f,  1.0f,  1.0f, 1.0f
    };
    quadVBO.bind();
    quadVBO.allocate(quadVertices, sizeof(quadVertices));
    quadVBO.release();
}
void PostProcessor::applyEffects(QOpenGLShaderProgram& program)
{
    if (!fbo || !effectsEnabled) {
        glDisable(GL_DEPTH_TEST);
        program.bind();
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, fbo->texture());
        program.setUniformValue("screenTexture", 0);
        program.setUniformValue("useVignette", false);
        program.setUniformValue("useFilmGrain", false);
        program.setUniformValue("useNegative", false);
        program.setUniformValue("useSepia", false);
        program.setUniformValue("useFisheye", false);
        program.setUniformValue("useColorFilter", false);
        program.setUniformValue("useGrayscale", false);
        quadVBO.bind();
        program.enableAttributeArray(0);
        program.setAttributeBuffer(0, GL_FLOAT, 0, 2, 4 * sizeof(float));
        program.enableAttributeArray(1);
        program.setAttributeBuffer(1, GL_FLOAT, 2 * sizeof(float), 2, 4 * sizeof(float));
        glDrawArrays(GL_TRIANGLES, 0, 6);
        quadVBO.release();
        program.release();
        glEnable(GL_DEPTH_TEST);
        return;
    }
    glDisable(GL_DEPTH_TEST);
    program.bind();
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, fbo->texture());
    program.setUniformValue("screenTexture", 0);
    program.setUniformValue("useVignette", useVignette);
    program.setUniformValue("useFilmGrain", useFilmGrain);
    program.setUniformValue("useNegative", useNegative);
    program.setUniformValue("useSepia", useSepia);
    program.setUniformValue("useFisheye", useFisheye);
    program.setUniformValue("useColorFilter", useColorFilter);
    program.setUniformValue("useGrayscale", useGrayscale);
    program.setUniformValue("vignetteIntensity", vignetteIntensity);
    program.setUniformValue("filmGrainIntensity", filmGrainIntensity);
    program.setUniformValue("fisheyeStrength", fisheyeStrength);
    program.setUniformValue("colorFilterColor", colorFilterColor);
    quadVBO.bind();
    program.enableAttributeArray(0);
    program.setAttributeBuffer(0, GL_FLOAT, 0, 2, 4 * sizeof(float));
    program.enableAttributeArray(1);
    program.setAttributeBuffer(1, GL_FLOAT, 2 * sizeof(float), 2, 4 * sizeof(float));
    glDrawArrays(GL_TRIANGLES, 0, 6);
    quadVBO.release();
    program.release();
    glEnable(GL_DEPTH_TEST);
}


// ====== postprocessor.h ====== //

class QOpenGLShaderProgram;
class PostProcessor : protected QOpenGLFunctions
{
public:
    PostProcessor();
    ~PostProcessor();
    void initialize(int width, int height);
    void resize(int width, int height);
    void beginRender();
    void endRender();
    void applyEffects(QOpenGLShaderProgram& program);
    void toggleEffects(bool enabled) { effectsEnabled = enabled; }
    void setVignetteEnabled(bool enabled) { useVignette = enabled; }
    void setFilmGrainEnabled(bool enabled) { useFilmGrain = enabled; }
    void setNegativeEnabled(bool enabled) { useNegative = enabled; }
    void setSepiaEnabled(bool enabled) { useSepia = enabled; }
    void setFisheyeEnabled(bool enabled) { useFisheye = enabled; }
    void setColorFilterEnabled(bool enabled) { useColorFilter = enabled; }
    void setGrayscaleEnabled(bool enabled) { useGrayscale = enabled; }
    void setVignetteIntensity(float intensity) { vignetteIntensity = intensity; }
    void setFilmGrainIntensity(float intensity) { filmGrainIntensity = intensity; }
    void setFisheyeStrength(float strength) { fisheyeStrength = strength; }
    void setColorFilterColor(const QVector3D& color) { colorFilterColor = color; }
    QVector3D getColorFilterColor() const { return colorFilterColor; }
    bool areEffectsEnabled() const { return effectsEnabled; }
private:
    void setupScreenQuad();
    QOpenGLFramebufferObject* fbo;
    QOpenGLBuffer quadVBO;
    int screenWidth;
    int screenHeight;
    bool effectsEnabled = true;
    bool useVignette = false;
    bool useFilmGrain = false;
    bool useNegative = false;
    bool useSepia = false;
    bool useFisheye = false;
    bool useColorFilter = false;
    bool useGrayscale = false;
    float vignetteIntensity = 0.5f;
    float filmGrainIntensity = 0.1f;
    float fisheyeStrength = 0.5f;
    QVector3D colorFilterColor = QVector3D(1.0f, 1.0f, 1.0f);
};


// ====== primitives.cpp ====== //

Cube::Cube(const QString& textureName) : textureName(textureName) {
    setupVertices();
}
void Cube::initialize() {
    if (!TextureManager::instance().contains(textureName)) {
        TextureManager::instance().loadTexture(":/textures/grass.png", textureName);
    }
}
void Cube::setupVertices() {
    float w_div_2 = 0.5f;
    QVector<VertexData> vertexes;
    vertexes.append(VertexData(QVector3D(-w_div_2, w_div_2, w_div_2),  // верх-лево
                               QVector2D(0.0f, 1.0f),
                               QVector3D(0.0f, 0.0f, 1.0f)));
    vertexes.append(VertexData(QVector3D(-w_div_2, -w_div_2, w_div_2), // низ-лево
                               QVector2D(0.0f, 0.0f),
                               QVector3D(0.0f, 0.0f, 1.0f)));
    vertexes.append(VertexData(QVector3D(w_div_2, w_div_2, w_div_2),    // верх-право
                               QVector2D(1.0f, 1.0f),
                               QVector3D(0.0f, 0.0f, 1.0f)));
    vertexes.append(VertexData(QVector3D(w_div_2, -w_div_2, w_div_2),   // низ-право
                               QVector2D(1.0f, 0.0f),
                               QVector3D(0.0f, 0.0f, 1.0f)));
    vertexes.append(VertexData(QVector3D(w_div_2, w_div_2, -w_div_2),   // верх-право
                               QVector2D(1.0f, 1.0f),
                               QVector3D(0.0f, 0.0f, -1.0f)));
    vertexes.append(VertexData(QVector3D(w_div_2, -w_div_2, -w_div_2),  // низ-право
                               QVector2D(1.0f, 0.0f),
                               QVector3D(0.0f, 0.0f, -1.0f)));
    vertexes.append(VertexData(QVector3D(-w_div_2, w_div_2, -w_div_2),  // верх-лево
                               QVector2D(0.0f, 1.0f),
                               QVector3D(0.0f, 0.0f, -1.0f)));
    vertexes.append(VertexData(QVector3D(-w_div_2, -w_div_2, -w_div_2), // низ-лево
                               QVector2D(0.0f, 0.0f),
                               QVector3D(0.0f, 0.0f, -1.0f)));
    vertexes.append(VertexData(QVector3D(-w_div_2, w_div_2, -w_div_2),  // верх-зад
                               QVector2D(0.0f, 1.0f),
                               QVector3D(-1.0f, 0.0f, 0.0f)));
    vertexes.append(VertexData(QVector3D(-w_div_2, -w_div_2, -w_div_2), // низ-зад
                               QVector2D(0.0f, 0.0f),
                               QVector3D(-1.0f, 0.0f, 0.0f)));
    vertexes.append(VertexData(QVector3D(-w_div_2, w_div_2, w_div_2),   // верх-перед
                               QVector2D(1.0f, 1.0f),
                               QVector3D(-1.0f, 0.0f, 0.0f)));
    vertexes.append(VertexData(QVector3D(-w_div_2, -w_div_2, w_div_2),  // низ-перед
                               QVector2D(1.0f, 0.0f),
                               QVector3D(-1.0f, 0.0f, 0.0f)));
    vertexes.append(VertexData(QVector3D(w_div_2, w_div_2, w_div_2),    // верх-перед
                               QVector2D(0.0f, 1.0f),
                               QVector3D(1.0f, 0.0f, 0.0f)));
    vertexes.append(VertexData(QVector3D(w_div_2, -w_div_2, w_div_2),   // низ-перед
                               QVector2D(0.0f, 0.0f),
                               QVector3D(1.0f, 0.0f, 0.0f)));
    vertexes.append(VertexData(QVector3D(w_div_2, w_div_2, -w_div_2),   // верх-зад
                               QVector2D(1.0f, 1.0f),
                               QVector3D(1.0f, 0.0f, 0.0f)));
    vertexes.append(VertexData(QVector3D(w_div_2, -w_div_2, -w_div_2),  // низ-зад
                               QVector2D(1.0f, 0.0f),
                               QVector3D(1.0f, 0.0f, 0.0f)));
    vertexes.append(VertexData(QVector3D(-w_div_2, w_div_2, -w_div_2),  // зад-лево
                               QVector2D(0.0f, 1.0f),
                               QVector3D(0.0f, 1.0f, 0.0f)));
    vertexes.append(VertexData(QVector3D(-w_div_2, w_div_2, w_div_2),   // перед-лево
                               QVector2D(0.0f, 0.0f),
                               QVector3D(0.0f, 1.0f, 0.0f)));
    vertexes.append(VertexData(QVector3D(w_div_2, w_div_2, -w_div_2),   // зад-право
                               QVector2D(1.0f, 1.0f),
                               QVector3D(0.0f, 1.0f, 0.0f)));
    vertexes.append(VertexData(QVector3D(w_div_2, w_div_2, w_div_2),    // перед-право
                               QVector2D(1.0f, 0.0f),
                               QVector3D(0.0f, 1.0f, 0.0f)));
    vertexes.append(VertexData(QVector3D(-w_div_2, -w_div_2, w_div_2),  // перед-лево
                               QVector2D(0.0f, 1.0f),
                               QVector3D(0.0f, -1.0f, 0.0f)));
    vertexes.append(VertexData(QVector3D(-w_div_2, -w_div_2, -w_div_2), // зад-лево
                               QVector2D(0.0f, 0.0f),
                               QVector3D(0.0f, -1.0f, 0.0f)));
    vertexes.append(VertexData(QVector3D(w_div_2, -w_div_2, w_div_2),   // перед-право
                               QVector2D(1.0f, 1.0f),
                               QVector3D(0.0f, -1.0f, 0.0f)));
    vertexes.append(VertexData(QVector3D(w_div_2, -w_div_2, -w_div_2),  // зад-право
                               QVector2D(1.0f, 0.0f),
                               QVector3D(0.0f, -1.0f, 0.0f)));
    QVector<GLuint> indexes;
    for (int i = 0; i < 24; i += 4) {
        indexes.append(i + 0);
        indexes.append(i + 1);
        indexes.append(i + 2);
        indexes.append(i + 2);
        indexes.append(i + 1);
        indexes.append(i + 3);
    }
    vertexBuffer.create();
    vertexBuffer.bind();
    vertexBuffer.allocate(vertexes.constData(), vertexes.size() * sizeof(VertexData));
    vertexBuffer.release();
    indexBuffer.create();
    indexBuffer.bind();
    indexBuffer.allocate(indexes.constData(), indexes.size() * sizeof(GLuint));
    indexBuffer.release();
}
void Cube::render(QOpenGLShaderProgram& program) {
    program.setUniformValue("model", modelMatrix);
    QOpenGLTexture* texture = TextureManager::instance().getTexture(textureName);
    if (texture) {
        texture->bind();
        program.setUniformValue("ourTexture", 0);
    }
    vertexBuffer.bind();
    indexBuffer.bind();
    int posLoc = program.attributeLocation("aPos");
    program.enableAttributeArray(posLoc);
    program.setAttributeBuffer(posLoc, GL_FLOAT, offsetof(VertexData, position), 3, sizeof(VertexData));
    int texLoc = program.attributeLocation("aTexCoord");
    program.enableAttributeArray(texLoc);
    program.setAttributeBuffer(texLoc, GL_FLOAT, offsetof(VertexData, texCoord), 2, sizeof(VertexData));
    int normalLoc = program.attributeLocation("aNormal");
    if (normalLoc != -1) {
        program.enableAttributeArray(normalLoc);
        program.setAttributeBuffer(normalLoc, GL_FLOAT, offsetof(VertexData, normal), 3, sizeof(VertexData));
    }
    glDrawElements(GL_TRIANGLES, indexBuffer.size(), GL_UNSIGNED_INT, 0);
    vertexBuffer.release();
    indexBuffer.release();
    if (texture) texture->release();
}
Pyramid::Pyramid(const QString& textureName) : textureName(textureName)
{
    setupVertices();
}
void Pyramid::initialize()
{
    if (!TextureManager::instance().contains(textureName)) {
        TextureManager::instance().loadTexture(":/textures/default.png", textureName);
    }
}
void Pyramid::setupVertices()
{
    QVector<VertexData> vertexes;
    vertexes.append(VertexData(QVector3D(-0.5f, -0.5f, -0.5f), QVector2D(0.0f, 0.0f), QVector3D(0.0f, -1.0f, 0.0f)));  // 0
    vertexes.append(VertexData(QVector3D( 0.5f, -0.5f, -0.5f), QVector2D(1.0f, 0.0f), QVector3D(0.0f, -1.0f, 0.0f)));  // 1
    vertexes.append(VertexData(QVector3D( 0.5f, -0.5f,  0.5f), QVector2D(1.0f, 1.0f), QVector3D(0.0f, -1.0f, 0.0f)));  // 2
    vertexes.append(VertexData(QVector3D(-0.5f, -0.5f,  0.5f), QVector2D(0.0f, 1.0f), QVector3D(0.0f, -1.0f, 0.0f)));  // 3
    const QVector3D top(0.0f, 0.5f, 0.0f);
    QVector3D frontNormal = QVector3D::crossProduct(
                                QVector3D(-0.5f, -0.5f, 0.5f) - top,
                                QVector3D(0.5f, -0.5f, 0.5f) - top
                                ).normalized();
    vertexes.append(VertexData(top, QVector2D(0.5f, 1.0f), frontNormal));  // 4
    vertexes.append(VertexData(QVector3D(-0.5f, -0.5f, 0.5f), QVector2D(0.0f, 0.0f), frontNormal));  // 5
    vertexes.append(VertexData(QVector3D(0.5f, -0.5f, 0.5f), QVector2D(1.0f, 0.0f), frontNormal));   // 6
    QVector3D rightNormal = QVector3D::crossProduct(
                                QVector3D(0.5f, -0.5f, 0.5f) - top,
                                QVector3D(0.5f, -0.5f, -0.5f) - top
                                ).normalized();
    vertexes.append(VertexData(top, QVector2D(0.5f, 1.0f), rightNormal));  // 7
    vertexes.append(VertexData(QVector3D(0.5f, -0.5f, 0.5f), QVector2D(0.0f, 0.0f), rightNormal));  // 8
    vertexes.append(VertexData(QVector3D(0.5f, -0.5f, -0.5f), QVector2D(1.0f, 0.0f), rightNormal)); // 9
    QVector3D backNormal = QVector3D::crossProduct(
                               QVector3D(0.5f, -0.5f, -0.5f) - top,
                               QVector3D(-0.5f, -0.5f, -0.5f) - top
                               ).normalized();
    vertexes.append(VertexData(top, QVector2D(0.5f, 1.0f), backNormal));   // 10
    vertexes.append(VertexData(QVector3D(0.5f, -0.5f, -0.5f), QVector2D(0.0f, 0.0f), backNormal));  // 11
    vertexes.append(VertexData(QVector3D(-0.5f, -0.5f, -0.5f), QVector2D(1.0f, 0.0f), backNormal)); // 12
    QVector3D leftNormal = QVector3D::crossProduct(
                               QVector3D(-0.5f, -0.5f, -0.5f) - top,
                               QVector3D(-0.5f, -0.5f, 0.5f) - top
                               ).normalized();
    vertexes.append(VertexData(top, QVector2D(0.5f, 1.0f), leftNormal));  // 13
    vertexes.append(VertexData(QVector3D(-0.5f, -0.5f, -0.5f), QVector2D(0.0f, 0.0f), leftNormal)); // 14
    vertexes.append(VertexData(QVector3D(-0.5f, -0.5f, 0.5f), QVector2D(1.0f, 0.0f), leftNormal));  // 15
    QVector<GLuint> indexes = {
        0, 1, 2,
        2, 3, 0,
        4, 5, 6,
        7, 8, 9,
        10, 11, 12,
        13, 14, 15
    };
    vertexBuffer.create();
    vertexBuffer.bind();
    vertexBuffer.allocate(vertexes.constData(), vertexes.size() * sizeof(VertexData));
    vertexBuffer.release();
    indexBuffer.create();
    indexBuffer.bind();
    indexBuffer.allocate(indexes.constData(), indexes.size() * sizeof(GLuint));
    indexBuffer.release();
}
void Pyramid::render(QOpenGLShaderProgram& program)
{
    program.setUniformValue("model", modelMatrix);
    QOpenGLTexture* texture = TextureManager::instance().getTexture(textureName);
    if (texture) {
        texture->bind();
        program.setUniformValue("ourTexture", 0);
    }
    vertexBuffer.bind();
    indexBuffer.bind();
    int posLoc = program.attributeLocation("aPos");
    program.enableAttributeArray(posLoc);
    program.setAttributeBuffer(posLoc, GL_FLOAT, offsetof(VertexData, position), 3, sizeof(VertexData));
    int texLoc = program.attributeLocation("aTexCoord");
    program.enableAttributeArray(texLoc);
    program.setAttributeBuffer(texLoc, GL_FLOAT, offsetof(VertexData, texCoord), 2, sizeof(VertexData));
    int normalLoc = program.attributeLocation("aNormal");
    if (normalLoc != -1) {
        program.enableAttributeArray(normalLoc);
        program.setAttributeBuffer(normalLoc, GL_FLOAT, offsetof(VertexData, normal), 3, sizeof(VertexData));
    }
    glDrawElements(GL_TRIANGLES, 18, GL_UNSIGNED_INT, 0);
    vertexBuffer.release();
    indexBuffer.release();
    if (texture) texture->release();
}
Sphere::Sphere(const QString& textureName, float radius, int sectors, int stacks)
    : textureName(textureName), radius(radius), sectors(sectors), stacks(stacks)
{
    setupVertices();
}
void Sphere::initialize()
{
    if (!TextureManager::instance().contains(textureName)) {
        TextureManager::instance().loadTexture(":/textures/default.png", textureName);
    }
}
void Sphere::setupVertices()
{
    QVector<VertexData> vertices;
    QVector<GLuint> indices;
    const float PI = 3.14159265358979323846f;
    float x, y, z, xy;
    float nx, ny, nz, lengthInv = 1.0f / radius;
    float s, t;
    float sectorStep = 2 * PI / sectors;
    float stackStep = PI / stacks;
    float sectorAngle, stackAngle;
    for(int i = 0; i <= stacks; ++i)
    {
        stackAngle = PI / 2 - i * stackStep;
        xy = radius * cosf(stackAngle);
        z = radius * sinf(stackAngle);
        for(int j = 0; j <= sectors; ++j)
        {
            sectorAngle = j * sectorStep;
            x = xy * cosf(sectorAngle);
            y = xy * sinf(sectorAngle);
            nx = x * lengthInv;
            ny = y * lengthInv;
            nz = z * lengthInv;
            s = (float)j / sectors;
            t = (float)i / stacks;
            vertices.append(VertexData(
                QVector3D(x, y, z),
                QVector2D(s, t),
                QVector3D(nx, ny, nz)
                ));
        }
    }
    int k1, k2;
    for(int i = 0; i < stacks; ++i)
    {
        k1 = i * (sectors + 1);
        k2 = k1 + sectors + 1;
        for(int j = 0; j < sectors; ++j, ++k1, ++k2)
        {
            if(i != 0)
            {
                indices.append(k1);
                indices.append(k2);
                indices.append(k1 + 1);
            }
            if(i != (stacks-1))
            {
                indices.append(k1 + 1);
                indices.append(k2);
                indices.append(k2 + 1);
            }
        }
    }
    vertexBuffer.create();
    vertexBuffer.bind();
    vertexBuffer.allocate(vertices.constData(), vertices.size() * sizeof(VertexData));
    vertexBuffer.release();
    indexBuffer.create();
    indexBuffer.bind();
    indexBuffer.allocate(indices.constData(), indices.size() * sizeof(GLuint));
    indexBuffer.release();
}
void Sphere::render(QOpenGLShaderProgram& program)
{
    program.setUniformValue("model", modelMatrix);
    QOpenGLTexture* texture = TextureManager::instance().getTexture(textureName);
    if (texture) {
        texture->bind();
        program.setUniformValue("ourTexture", 0);
    }
    vertexBuffer.bind();
    indexBuffer.bind();
    int posLoc = program.attributeLocation("aPos");
    program.enableAttributeArray(posLoc);
    program.setAttributeBuffer(posLoc, GL_FLOAT, offsetof(VertexData, position), 3, sizeof(VertexData));
    int texLoc = program.attributeLocation("aTexCoord");
    program.enableAttributeArray(texLoc);
    program.setAttributeBuffer(texLoc, GL_FLOAT, offsetof(VertexData, texCoord), 2, sizeof(VertexData));
    int normalLoc = program.attributeLocation("aNormal");
    if (normalLoc != -1) {
        program.enableAttributeArray(normalLoc);
        program.setAttributeBuffer(normalLoc, GL_FLOAT, offsetof(VertexData, normal), 3, sizeof(VertexData));
    }
    glDrawElements(GL_TRIANGLES, indexBuffer.size(), GL_UNSIGNED_INT, 0);
    vertexBuffer.release();
    indexBuffer.release();
    if (texture) texture->release();
}
Cylinder::Cylinder(const QString& textureName, float radius, float height, int sectors, int stacks)
    : textureName(textureName), radius(radius), height(height), sectors(sectors), stacks(stacks)
{
    setupVertices();
}
void Cylinder::initialize()
{
    if (!TextureManager::instance().contains(textureName)) {
        TextureManager::instance().loadTexture(":/textures/default.png", textureName);
    }
}
void Cylinder::setupVertices()
{
    QVector<VertexData> vertices;
    QVector<GLuint> indices;
    const float PI = 3.14159265358979323846f;
    float sectorStep = 2 * PI / sectors;
    float stackHeight = height / stacks;
    for(int i = 0; i <= stacks; ++i) {
        float y = -height / 2.0f + i * stackHeight;
        for(int j = 0; j <= sectors; ++j) {
            float sectorAngle = j * sectorStep;
            float x = radius * cosf(sectorAngle);
            float z = radius * sinf(sectorAngle);
            QVector3D normal(cosf(sectorAngle), 0.0f, sinf(sectorAngle));
            float s = (float)j / sectors;
            float t = (float)i / stacks;
            vertices.append(VertexData(
                QVector3D(x, y, z),
                QVector2D(s, t),
                normal
                ));
        }
    }
    for(int i = 0; i < stacks; ++i) {
        int k1 = i * (sectors + 1);
        int k2 = k1 + sectors + 1;
        for(int j = 0; j < sectors; ++j, ++k1, ++k2) {
            indices.append(k1);
            indices.append(k1 + 1);
            indices.append(k2);
            indices.append(k2);
            indices.append(k1 + 1);
            indices.append(k2 + 1);
        }
    }
    int baseIndexTop = vertices.size();
    float yTop = height / 2.0f;
    vertices.append(
        VertexData(QVector3D(0.0f, yTop, 0.0f), QVector2D(0.5f, 0.5f), QVector3D(0.0f, 1.0f, 0.0f)));
    for (int j = 0; j <= sectors; ++j) {
        float sectorAngle = j * sectorStep;
        float x = radius * cosf(sectorAngle);
        float z = radius * sinf(sectorAngle);
        vertices.append(
            VertexData(QVector3D(x, yTop, z),
                       QVector2D(0.5f + 0.5f * cosf(sectorAngle), 0.5f + 0.5f * sinf(sectorAngle)),
                       QVector3D(0.0f, 1.0f, 0.0f)));
                    }
                    for(int j = 0; j < sectors; ++j) {
                        indices.append(baseIndexTop);
                        indices.append(baseIndexTop + j + 2);
                        indices.append(baseIndexTop + j + 1);
                    }
                    int baseIndexBottom = vertices.size();
                    float yBottom = -height / 2.0f;
                    vertices.append(VertexData(
                        QVector3D(0.0f, yBottom, 0.0f),
                        QVector2D(0.5f, 0.5f),
                        QVector3D(0.0f, -1.0f, 0.0f)
                        ));
                    for(int j = 0; j <= sectors; ++j) {
                        float sectorAngle = j * sectorStep;
                        float x = radius * cosf(sectorAngle);
                        float z = radius * sinf(sectorAngle);
                        vertices.append(VertexData(
                            QVector3D(x, yBottom, z),
                            QVector2D(0.5f + 0.5f * cosf(sectorAngle),
                                      0.5f + 0.5f * sinf(sectorAngle)),
                            QVector3D(0.0f, -1.0f, 0.0f)
                            ));
                    }
                    for(int j = 0; j < sectors; ++j) {
                        indices.append(baseIndexBottom);
                        indices.append(baseIndexBottom + j + 1);
                        indices.append(baseIndexBottom + j + 2);
                    }
                    vertexBuffer.bind();
                    vertexBuffer.allocate(vertices.constData(), vertices.size() * sizeof(VertexData));
                    vertexBuffer.release();
                    indexBuffer.bind();
                    indexBuffer.allocate(indices.constData(), indices.size() * sizeof(GLuint));
                    indexBuffer.release();
}
void Cylinder::render(QOpenGLShaderProgram& program)
{
    program.setUniformValue("model", modelMatrix);
    QOpenGLTexture* texture = TextureManager::instance().getTexture(textureName);
    if (texture) {
        texture->bind();
        program.setUniformValue("ourTexture", 0);
    }
    vertexBuffer.bind();
    indexBuffer.bind();
    int posLoc = program.attributeLocation("aPos");
    program.enableAttributeArray(posLoc);
    program.setAttributeBuffer(posLoc, GL_FLOAT, offsetof(VertexData, position), 3, sizeof(VertexData));
    int texLoc = program.attributeLocation("aTexCoord");
    program.enableAttributeArray(texLoc);
    program.setAttributeBuffer(texLoc, GL_FLOAT, offsetof(VertexData, texCoord), 2, sizeof(VertexData));
    int normalLoc = program.attributeLocation("aNormal");
    if (normalLoc != -1) {
        program.enableAttributeArray(normalLoc);
        program.setAttributeBuffer(normalLoc, GL_FLOAT, offsetof(VertexData, normal), 3, sizeof(VertexData));
    }
    glDrawElements(GL_TRIANGLES, indexBuffer.size(), GL_UNSIGNED_INT, 0);
    vertexBuffer.release();
    indexBuffer.release();
    if (texture) texture->release();
}


// ====== primitives.h ====== //

class Cube : public Shape {
public:
    Cube(const QString& textureName = "default");
    ~Cube() = default;
    void initialize() override;
    void render(QOpenGLShaderProgram& program) override;
private:
    void setupVertices();
    QString textureName;
};
class Pyramid : public Shape {
public:
    Pyramid(const QString& textureName = "default");
    ~Pyramid() = default;
    void initialize() override;
    void render(QOpenGLShaderProgram& program) override;
private:
    void setupVertices();
    QString textureName;
};
class Sphere : public Shape {
public:
    Sphere(const QString& textureName = "default", float radius = 1.0f, int sectors = 36, int stacks = 18);
    ~Sphere() = default;
    void initialize() override;
    void render(QOpenGLShaderProgram& program) override;
private:
    void setupVertices();
    QString textureName;
    float radius;
    int sectors;
    int stacks;
};
class Cylinder : public Shape {
public:
    Cylinder(const QString& textureName = "default", float radius = 1.0f, float height = 2.0f,
             int sectors = 36, int stacks = 1);
    ~Cylinder() = default;
    void initialize() override;
    void render(QOpenGLShaderProgram& program) override;
private:
    void setupVertices();
    QString textureName;
    float radius;
    float height;
    int sectors;
    int stacks;
};


// ====== scene.cpp ====== //

Scene::Scene()
{
    cameraPos = QVector3D(0, 0, 5);
    cameraFront = QVector3D(0, 0, -1);
    cameraUp = QVector3D(0, 1, 0);
}
Scene::~Scene() {
    qDeleteAll(shapes);
}
void Scene::addShape(Shape* shape) {
    shapes.append(shape);
}
void Scene::renderAll(QOpenGLShaderProgram& program) {
    program.bind();
    view.setToIdentity();
    view.lookAt(cameraPos, cameraPos + cameraFront, cameraUp);
    program.setUniformValue("view", view);
    program.setUniformValue("projection", projection);
    for (Shape* shape : shapes) {
        shape->render(program);
    }
    program.release();
}
void Scene::setSkybox(Skybox *skybox_new) {
    skybox = skybox_new;
}
void Scene::renderSkybox(QOpenGLShaderProgram &program) {
    program.bind();
    view.setToIdentity();
    view.lookAt(cameraPos, cameraPos + cameraFront, cameraUp);
    QMatrix4x4 viewWithoutTranslation = view;
    viewWithoutTranslation.setColumn(3, QVector4D(0, 0, 0, 1));
    program.setUniformValue("view", viewWithoutTranslation);
    program.setUniformValue("projection", projection);
    skybox->render(program);
    program.release();
}
QMatrix4x4 Scene::getViewMatrix() const {
    return view;
}
QMatrix4x4 Scene::getProjectionMatrix() const {
    return projection;
}
void Scene::setCameraPosition(const QVector3D& position) {
    cameraPos = position;
}
void Scene::setCameraFront(const QVector3D& front) {
    cameraFront = front;
}
void Scene::setCameraUp(const QVector3D& up) {
    cameraUp = up;
}
void Scene::resize(int w, int h) {
    projection.setToIdentity();
    projection.perspective(45.0f, float(w) / float(h), 0.1f, 1000.0f);
}


// ====== scene.h ====== //

class Scene
{
public:
    Scene();
    ~Scene();
    void addShape(Shape* shape);
    void renderAll(QOpenGLShaderProgram& program);
    void setSkybox(Skybox* skybox_new);
    void renderSkybox(QOpenGLShaderProgram& program);
    QMatrix4x4 getViewMatrix() const;
    QMatrix4x4 getProjectionMatrix() const;
    void setCameraPosition(const QVector3D& position);
    void setCameraFront(const QVector3D& front);
    void setCameraUp(const QVector3D& up);
    void resize(int w, int h);
    QVector3D getCameraPosition() const { return cameraPos; }
    QVector3D getCameraFront() const { return cameraFront; }
    QVector3D getCameraUp() const { return cameraUp; }
    const QVector<Shape*>& getShapes() const { return shapes; }
private:
    QVector<Shape*> shapes;
    Skybox *skybox;
    QMatrix4x4 projection;
    QMatrix4x4 view;
    QVector3D cameraPos;
    QVector3D cameraFront;
    QVector3D cameraUp;
};


// ====== shadermanager.cpp ====== //

ShaderManager& ShaderManager::instance()
{
    static ShaderManager instance;
    return instance;
}
bool ShaderManager::loadShaderProgram(const QString& name,
                                      const QString& vertexShaderPath,
                                      const QString& fragmentShaderPath)
{
    if (m_shaderPrograms.contains(name)) {
        return true;
    }
    QOpenGLShaderProgram* program = new QOpenGLShaderProgram();
    if (!program->addShaderFromSourceFile(QOpenGLShader::Vertex, vertexShaderPath)) {
        qWarning() << "Failed to compile vertex shader" << vertexShaderPath
                   << ":" << program->log();
        delete program;
        return false;
    }
    if (!program->addShaderFromSourceFile(QOpenGLShader::Fragment, fragmentShaderPath)) {
        qWarning() << "Failed to compile fragment shader" << fragmentShaderPath
                   << ":" << program->log();
        delete program;
        return false;
    }
    if (!program->link()) {
        qWarning() << "Failed to link shader program:" << program->log();
        delete program;
        return false;
    }
    m_shaderPrograms[name] = program;
    return true;
}
QOpenGLShaderProgram* ShaderManager::getShaderProgram(const QString& name)
{
    return m_shaderPrograms.value(name, nullptr);
}
void ShaderManager::cleanup()
{
    qDeleteAll(m_shaderPrograms);
    m_shaderPrograms.clear();
}


// ====== shadermanager.h ====== //

class ShaderManager
{
public:
    static ShaderManager& instance();
    ShaderManager(const ShaderManager&) = delete;
    ShaderManager& operator=(const ShaderManager&) = delete;
    bool loadShaderProgram(const QString& name,
                           const QString& vertexShaderPath,
                           const QString& fragmentShaderPath);
    QOpenGLShaderProgram* getShaderProgram(const QString& name);
    void cleanup();
private:
    ShaderManager() = default;
    ~ShaderManager() = default;
    QMap<QString, QOpenGLShaderProgram*> m_shaderPrograms;
};


// ====== shape.cpp ====== //

Shape::Shape()
    : indexBuffer(QOpenGLBuffer::IndexBuffer) {
    vertexBuffer.create();
    indexBuffer.create();
}
Shape::~Shape() {
    vertexBuffer.destroy();
    indexBuffer.destroy();
}
void Shape::setPosition(const QVector3D& position) {
    this->position = position;
    updateModelMatrix();
}
void Shape::setRotation(float angle, const QVector3D& axis) {
    rotationQuat = QQuaternion::fromAxisAndAngle(axis, angle) * rotationQuat;
    updateModelMatrix();
}
void Shape::setScale(const QVector3D& scale) {
    scaleFactor = scale;
    updateModelMatrix();
}
void Shape::updateModelMatrix() {
    modelMatrix.setToIdentity();
    modelMatrix.translate(position);
    modelMatrix.rotate(rotationQuat);
    modelMatrix.scale(scaleFactor);
}


// ====== shape.h ====== //

struct VertexData {
    VertexData() = default;
    VertexData(QVector3D p, QVector2D t, QVector3D n)
        : position(p), texCoord(t), normal(n) {}
    QVector3D position;
    QVector2D texCoord;
    QVector3D normal;
};
class Shape {
public:
    Shape();
    virtual ~Shape();
    virtual void initialize() = 0;
    virtual void render(QOpenGLShaderProgram& program) = 0;
    void setPosition(const QVector3D& position);
    void setRotation(float angle, const QVector3D& axis);
    void setScale(const QVector3D& scale);
protected:
    void updateModelMatrix();
    QMatrix4x4 modelMatrix;
    QOpenGLBuffer vertexBuffer;
    QOpenGLBuffer indexBuffer;
    QQuaternion rotationQuat;
    QVector3D position = QVector3D(0, 0, 0);
    QVector3D scaleFactor = QVector3D(1, 1, 1);
};


// ====== skybox.cpp ====== //

Skybox::Skybox(const QString& textureName) : textureName(textureName) {
    setupVertices();
}
void Skybox::initialize() {
    if (!TextureManager::instance().contains(textureName)) {
        TextureManager::instance().loadTexture(":/skyboxes/default.jpg", textureName);
    }
}
void Skybox::setupVertices() {
    float w_div_2 = 0.5f;
    float border = 0.0003f; // Небольшой отступ от краев текстуры
    QVector<VertexData> vertexes;
    vertexes.append(VertexData(QVector3D(-w_div_2, w_div_2, w_div_2),
                               QVector2D(1.0f + border, (2.0f / 3.0f) - border),
                               QVector3D(0.0, 0.0, -1.0)));
    vertexes.append(VertexData(QVector3D(-w_div_2, -w_div_2, w_div_2),
                               QVector2D(1.0f + border, (1.0f / 3.0f) + border),
                               QVector3D(0.0, 0.0, -1.0)));
    vertexes.append(VertexData(QVector3D(w_div_2, w_div_2, w_div_2),
                               QVector2D((3.0f / 4.0f) - border, (2.0f / 3.0f) - border),
                               QVector3D(0.0, 0.0, -1.0)));
    vertexes.append(VertexData(QVector3D(w_div_2, -w_div_2, w_div_2),
                               QVector2D((3.0f / 4.0f) - border, (1.0f / 3.0f) + border),
                               QVector3D(0.0, 0.0, -1.0)));
    vertexes.append(VertexData(QVector3D(w_div_2, w_div_2, w_div_2),
                               QVector2D((3.0f / 4.0f) - border, (2.0f / 3.0f) - border),
                               QVector3D(-1.0, 0.0, 0.0)));
    vertexes.append(VertexData(QVector3D(w_div_2, -w_div_2, w_div_2),
                               QVector2D((3.0f / 4.0f) - border, (1.0f / 3.0f) + border),
                               QVector3D(-1.0, 0.0, 0.0)));
    vertexes.append(VertexData(QVector3D(w_div_2, w_div_2, -w_div_2),
                               QVector2D((2.0f / 4.0f) + border, (2.0f / 3.0f) - border),
                               QVector3D(-1.0, 0.0, 0.0)));
    vertexes.append(VertexData(QVector3D(w_div_2, -w_div_2, -w_div_2),
                               QVector2D((2.0f / 4.0f) + border, (1.0f / 3.0f) + border),
                               QVector3D(-1.0, 0.0, 0.0)));
    vertexes.append(VertexData(QVector3D(w_div_2, w_div_2, w_div_2),
                               QVector2D((2.0f / 4.0f) - border, 1.0f - border),
                               QVector3D(0.0, -1.0, 0.0)));
    vertexes.append(VertexData(QVector3D(w_div_2, w_div_2, -w_div_2),
                               QVector2D((2.0f / 4.0f) - border, (2.0f / 3.0f) + border),
                               QVector3D(0.0, -1.0, 0.0)));
    vertexes.append(VertexData(QVector3D(-w_div_2, w_div_2, w_div_2),
                               QVector2D((1.0f / 4.0f) + border, 1.0f - border),
                               QVector3D(0.0, -1.0, 0.0)));
    vertexes.append(VertexData(QVector3D(-w_div_2, w_div_2, -w_div_2),
                               QVector2D((1.0f / 4.0f) + border, (2.0f / 3.0f) + border),
                               QVector3D(0.0, -1.0, 0.0)));
    vertexes.append(VertexData(QVector3D(w_div_2, w_div_2, -w_div_2),
                               QVector2D((2.0f / 4.0f) - border, (2.0f / 3.0f) + border),
                               QVector3D(0.0, 0.0, 1.0)));
    vertexes.append(VertexData(QVector3D(w_div_2, -w_div_2, -w_div_2),
                               QVector2D((2.0f / 4.0f) - border, (1.0f / 3.0f) - border),
                               QVector3D(0.0, 0.0, 1.0)));
    vertexes.append(VertexData(QVector3D(-w_div_2, w_div_2, -w_div_2),
                               QVector2D((1.0f / 4.0f) + border, (2.0f / 3.0f) + border),
                               QVector3D(0.0, 0.0, 1.0)));
    vertexes.append(VertexData(QVector3D(-w_div_2, -w_div_2, -w_div_2),
                               QVector2D((1.0f / 4.0f) + border, (1.0f / 3.0f) - border),
                               QVector3D(0.0, 0.0, 1.0)));
    vertexes.append(VertexData(QVector3D(-w_div_2, w_div_2, w_div_2),
                               QVector2D(-border, (2.0f / 3.0f) - border),
                               QVector3D(1.0, 0.0, 0.0)));
    vertexes.append(VertexData(QVector3D(-w_div_2, w_div_2, -w_div_2),
                               QVector2D((1.0f / 4.0f) - border, (2.0f / 3.0f) - border),
                               QVector3D(1.0, 0.0, 0.0)));
    vertexes.append(VertexData(QVector3D(-w_div_2, -w_div_2, w_div_2),
                               QVector2D(-border, (1.0f / 3.0f) + border),
                               QVector3D(1.0, 0.0, 0.0)));
    vertexes.append(VertexData(QVector3D(-w_div_2, -w_div_2, -w_div_2),
                               QVector2D((1.0f / 4.0f) - border, (1.0f / 3.0f) + border),
                               QVector3D(1.0, 0.0, 0.0)));
    vertexes.append(VertexData(QVector3D(-w_div_2, -w_div_2, w_div_2),
                               QVector2D((1.0f / 4.0f) + border, border),
                               QVector3D(0.0, 1.0, 0.0)));
    vertexes.append(VertexData(QVector3D(-w_div_2, -w_div_2, -w_div_2),
                               QVector2D((1.0f / 4.0f) + border, (1.0f / 3.0f) - border),
                               QVector3D(0.0, 1.0, 0.0)));
    vertexes.append(VertexData(QVector3D(w_div_2, -w_div_2, w_div_2),
                               QVector2D((2.0f / 4.0f) - border, border),
                               QVector3D(0.0, 1.0, 0.0)));
    vertexes.append(VertexData(QVector3D(w_div_2, -w_div_2, -w_div_2),
                               QVector2D((2.0f / 4.0f) - border, (1.0f / 3.0f) - border),
                               QVector3D(0.0, 1.0, 0.0)));
    QVector<GLuint> indexes;
    for (int i = 0; i < 24; i += 4) {
        indexes.append(i + 0);
        indexes.append(i + 1);
        indexes.append(i + 2);
        indexes.append(i + 2);
        indexes.append(i + 1);
        indexes.append(i + 3);
    }
    vertexBuffer.create();
    vertexBuffer.bind();
    vertexBuffer.allocate(vertexes.constData(), vertexes.size() * sizeof(VertexData));
    vertexBuffer.release();
    indexBuffer.create();
    indexBuffer.bind();
    indexBuffer.allocate(indexes.constData(), indexes.size() * sizeof(GLuint));
    indexBuffer.release();
}
void Skybox::render(QOpenGLShaderProgram& program) {
    program.setUniformValue("model", modelMatrix);
    QOpenGLTexture* texture = TextureManager::instance().getTexture(textureName);
    if (texture) {
        texture->bind();
        program.setUniformValue("skyTexture", 0);
    }
    vertexBuffer.bind();
    indexBuffer.bind();
    int posLoc = program.attributeLocation("aPos");
    program.enableAttributeArray(posLoc);
    program.setAttributeBuffer(posLoc, GL_FLOAT, offsetof(VertexData, position), 3, sizeof(VertexData));
    int texLoc = program.attributeLocation("aTexCoord");
    program.enableAttributeArray(texLoc);
    program.setAttributeBuffer(texLoc, GL_FLOAT, offsetof(VertexData, texCoord), 2, sizeof(VertexData));
    int normalLoc = program.attributeLocation("aNormal");
    if (normalLoc != -1) {
        program.enableAttributeArray(normalLoc);
        program.setAttributeBuffer(normalLoc, GL_FLOAT, offsetof(VertexData, normal), 3, sizeof(VertexData));
    }
    glDrawElements(GL_TRIANGLES, indexBuffer.size(), GL_UNSIGNED_INT, 0);
    vertexBuffer.release();
    indexBuffer.release();
    if (texture) texture->release();
}


// ====== skybox.h ====== //

class Skybox : public Shape {
public:
    Skybox(const QString& textureName = "default");
    ~Skybox() = default;
    void initialize() override;
    void render(QOpenGLShaderProgram& program) override;
private:
    void setupVertices();
    QString textureName;
};


// ====== texturemanager.cpp ====== //

TextureManager& TextureManager::instance()
{
    static TextureManager instance;
    return instance;
}
TextureManager::~TextureManager()
{
    clear();
}
QOpenGLTexture* TextureManager::loadTexture(const QString& path, const QString& name)
{
    if (textures.contains(name)) {
        qWarning() << "Texture" << name << "already loaded";
        return textures[name];
    }
    QImage image(path);
    if (image.isNull()) {
        qWarning() << "Failed to load texture:" << path;
        return nullptr;
    }
    QOpenGLTexture* texture = new QOpenGLTexture(image.flipped());
    texture->setMinificationFilter(QOpenGLTexture::LinearMipMapLinear);
    texture->setMagnificationFilter(QOpenGLTexture::Linear);
    texture->setWrapMode(QOpenGLTexture::Repeat);
    textures[name] = texture;
    return texture;
}
QOpenGLTexture* TextureManager::getTexture(const QString& name) const
{
    return textures.value(name, nullptr);
}
bool TextureManager::contains(const QString& name) const
{
    return textures.contains(name);
}
void TextureManager::removeTexture(const QString& name)
{
    if (textures.contains(name)) {
        delete textures[name];
        textures.remove(name);
    }
}
void TextureManager::clear() {
    if (QOpenGLContext::currentContext()) {
        qDeleteAll(textures);
        textures.clear();
    }
}


// ====== texturemanager.h ====== //

class TextureManager
{
public:
    static TextureManager& instance();
    QOpenGLTexture* loadTexture(const QString& path, const QString& name);
    QOpenGLTexture* getTexture(const QString& name) const;
    bool contains(const QString& name) const;
    void removeTexture(const QString& name);
    void clear();
private:
    TextureManager() = default;
    ~TextureManager();
    TextureManager(const TextureManager&) = delete;
    TextureManager& operator=(const TextureManager&) = delete;
    QMap<QString, QOpenGLTexture*> textures;
};


// ====== vshader.vsh ====== //

layout (location = 0) in vec3 aPos;
layout (location = 1) in vec2 aTexCoord;
layout (location = 2) in vec3 aNormal;
out vec2 TexCoord;
out vec3 Normal;
out vec3 FragPos;
uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;
void main()
{
    gl_Position = projection * view * model * vec4(aPos, 1.0);
    TexCoord = aTexCoord;
    FragPos = vec3(model * vec4(aPos, 1.0));
    Normal = mat3(transpose(inverse(model))) * aNormal;
}


// ====== vskybox.vsh ====== //

layout (location = 0) in vec3 aPos;
layout (location = 1) in vec2 aTexCoord;
out vec2 TexCoord;
uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;
void main()
{
    TexCoord = aTexCoord;
    gl_Position = projection * view * model * vec4(aPos, 1.0);
}
